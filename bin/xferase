#!/usr/bin/env ruby
# frozen_string_literal: true

# Setup & Config ---------------------------------------------------------------
require 'xferase'

Xferase::Config.parse_opts!
Xferase::Logger.open

ENV['MEDIAINFO_XML_PARSER'] ||= 'nokogiri'

SRC_DEST_MAP = {
  "#{Xferase::Config.staging}/desktop" => Xferase::Config.library,
  "#{Xferase::Config.staging}/web" => Xferase::Config.library_web,
}.select { |k, v| File.directory?(v) }

IMPORT_CMD = %(
  photein \
    --source %s \
    --dest %s \
    --optimize-for %s
) + (Xferase::Config.verbose ? ' --verbose' : '')

FORMAT_GROUPS = [%w(.jpg .dng .heic), %w(.mov .mp4), %w(.png)]

# Setup ------------------------------------------------------------------------
require 'debouncer'
require 'fileutils'
require 'pathname'
require 'rb-inotify'
require 'tmpdir'

Thread.abort_on_exception = true
SRC_DEST_MAP.keys.each(&FileUtils.method(:mkdir_p))

mutex = Mutex.new
debouncer = Debouncer.new(Xferase::Config.grace_period.to_i) do |*files|
  SRC_DEST_MAP.keys.each { |dir| FileUtils.ln(files, dir) }
  FileUtils.rm(files + Dir["#{Xferase::Config.staging}/web/*.DNG"]) # FIXME (ugly hack)

  break if debouncer.inspect_params[:threads] > 2 # don't let threads pile up

  mutex.synchronize do
    SRC_DEST_MAP.each do |src, dest|
      system(IMPORT_CMD % [src, dest, src.split('/').last])
    end
  rescue => e
    warn e.message
  end
end.reducer(:+)

# Resume from interruption/failure ---------------------------------------------
debouncer.call unless SRC_DEST_MAP.keys.all?(&Dir.method(:empty?))

Dir["#{Xferase::Config.inbox}/**/*"]
  .select(&File.method(:file?))
  .each { |path| debouncer.call(path) }

# Start ------------------------------------------------------------------------
Thread.new do
  call_debouncer = ->(event) do
    Xferase::Logger.debug("#{event.name}: new file detected in watch directory")
    debouncer.call(event.absolute_name)
  rescue => e
    warn e.message
  end

  import_notifier = INotify::Notifier.new
  import_notifier.watch(Xferase::Config.inbox, :close_write, &call_debouncer)

  # NOTE: inotify is not recursive,
  # so subdirectories must be watched separately!
  # (Why do Syncthing folders get special treatment?
  # Because ST works by creating hidden tempfiles and moving them upon completion)
  stfolders, simple_subdirs = Dir["#{Xferase::Config.inbox}/**/*"]
    .select(&File.method(:directory?))
    .partition { |dir| Dir.children(dir).include?('.stfolder') }

  simple_subdirs.each { |dir| import_notifier.watch(dir, :close_write, &call_debouncer) }
  stfolders.each { |dir| import_notifier.watch(dir, :moved_to, &call_debouncer) }

  import_notifier.run
end

Thread.new do
  sync_deletions = ->(event) do
    Xferase::Logger.info("#{event.name} has disappeared!")

    deleted_file   = Pathname(event.absolute_name).expand_path

    sister_file    = if deleted_file.to_s.start_with?(File.expand_path(Xferase::Config.library))
                      deleted_file.sub(Xferase::Config.library, Xferase::Config.library_web)
                    else
                      deleted_file.sub(Xferase::Config.library_web, Xferase::Config.library)
                    end

    sister_formats = FORMAT_GROUPS.find { |group| group.include?(deleted_file.extname) }

    related_files  = [deleted_file, sister_file]
      .product(sister_formats)
      .map { |file, ext| file.sub_ext(ext) }
      .select(&:file?)

    # (Why mv to tmpdir first? Why not rm straight away?
    # Because rm would recursively trigger this inotify callback.)
    related_files.each { |f| Xferase::Logger.info("deleting #{f.realpath}") }
    FileUtils.mv(related_files, Dir.tmpdir)
    FileUtils.rm(related_files.map { |f| File.join(Dir.tmpdir, f.basename) })
  end

  deletion_notifier = INotify::Notifier.new

  # NOTE: inotify is not recursive,
  # so subdirectories must be watched separately!
  (Dir["#{Xferase::Config.library}/**/*"] + Dir["#{Xferase::Config.library_web}/**/*"])
    .select(&File.method(:directory?))
    .each { |dir| deletion_notifier.watch(dir, :delete, &sync_deletions) }

  deletion_notifier.run
end.join
